This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
App.js
components/layout/AppLayout.jsx
components/privateRoute/PrivateRoute.jsx
components/publicRoute/PublicRoute.jsx
context/authContext.js
index.js
pages/accounts/AccountsPage.jsx
pages/accounts/ui/DepositWithdrawModal.jsx
pages/accounts/values/transactionTable.js
pages/forbidden/ForbiddenPage.jsx
pages/home/HomePage.jsx
pages/login/LoginPage.jsx
pages/notFound/NotFoundPage.jsx
pages/profile/ProfilePage.jsx
services/api.js
services/core.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="App.js">
import React from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { AuthProvider, useAuth } from './context/authContext';
import { PrivateRoute } from './components/privateRoute/PrivateRoute';
import { PublicRoute } from './components/publicRoute/PublicRoute';
import { AppLayout } from './components/layout/AppLayout';
import { HomePage } from './pages/home/HomePage';
import { LoginPage } from './pages/login/LoginPage';
import { ProfilePage } from './pages/profile/ProfilePage';
import { NotFoundPage } from './pages/notFound/NotFoundPage';
import { Spin } from 'antd'; // для индикатора загрузки
import { ForbiddenPage } from './pages/forbidden/ForbiddenPage';
import { AccountsPage } from './pages/accounts/AccountsPage';

function AppRoutes() {
  const { loading } = useAuth();
  if (loading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', marginTop: 100 }}>
        <Spin size="large" />
      </div>
    );
  }
  return (
    <Routes>
      <Route
        path="/"
        element={
          <PrivateRoute>
            <HomePage />
          </PrivateRoute>
        }
      />
      <Route
        path="/login"
        element={
          <PublicRoute>
            <LoginPage />
          </PublicRoute>
        }
      />
      <Route
        path="/profile"
        element={
          <PrivateRoute>
            <ProfilePage />
          </PrivateRoute>
        }
      />
      <Route
        path="/accounts"
        element={
          <PrivateRoute>
            <AccountsPage />
          </PrivateRoute>
        }
      />
      <Route path="/forbidden" element={<ForbiddenPage/>} />
      <Route path="*" element={<NotFoundPage />} />
    </Routes>
  );
}

function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        <AppLayout>
          <AppRoutes />
        </AppLayout>
      </BrowserRouter>
    </AuthProvider>
  );
}

export default App;
</file>

<file path="components/layout/AppLayout.jsx">
import React from 'react';
import { Layout, Menu } from 'antd';
import { Link, useLocation } from 'react-router-dom';
import { useAuth } from '../../context/authContext';

const { Header, Content, Footer } = Layout;

export const AppLayout = ({ children }) => {
  const location = useLocation();
  const { user, logout } = useAuth();

  // Если страница логина – показываем только содержимое (без шапки и футера)
  if (location.pathname === '/login') {
    return <>{children}</>;
  }

  const menuItems = [
    { key: '/', label: <Link to="/">Главная</Link> },
    { key: '/accounts', label: <Link to="/accounts">Счета</Link> },
    user ? { key: '/profile', label: <Link to="/profile">Профиль</Link> } : null,
    user
      ? { key: 'logout', label: <span onClick={logout}>Выйти</span> }
      : { key: '/login', label: <Link to="/login">Вход</Link> },
  ].filter(Boolean);

  return (
    <Layout className="layout" style={{ minHeight: '100vh' }}>
      <Header>
        <div className="logo" style={{ float: 'left', color: '#fff', marginRight: 20 }}>
          MyApp
        </div>
        <Menu
          theme="dark"
          mode="horizontal"
          selectedKeys={[location.pathname]}
          items={menuItems}
        />
      </Header>
      <Content style={{ padding: '0 50px', marginTop: 20 }}>
        <div className="site-layout-content" style={{ background: '#fff', padding: 24, minHeight: 280 }}>
          {children}
        </div>
      </Content>
      <Footer style={{ textAlign: 'center' }}>MyApp ©2025</Footer>
    </Layout>
  );
};
</file>

<file path="components/privateRoute/PrivateRoute.jsx">
import React from 'react';
import { Navigate } from 'react-router-dom';
import { getAccessToken, getRoleFromToken, isRoleAllowed } from '../../services/api';

export const PrivateRoute = ({ children }) => {
  const token = getAccessToken();

  if (!token) {
    return <Navigate to="/login" />;
  }

  const role = getRoleFromToken(token);
  if (!isRoleAllowed(role)) {
    return <Navigate to="/forbidden" />;
  }

  return children;
};
</file>

<file path="components/publicRoute/PublicRoute.jsx">
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../../context/authContext';

export const PublicRoute = ({ children }) => {
  const { user } = useAuth();
  // Если пользователь уже авторизован – перенаправляем на главную
  return user ? <Navigate to="/" /> : children;
};
</file>

<file path="context/authContext.js">
import React, { createContext, useState, useContext, useEffect } from 'react';
import {
  authApiRequest,
  setTokens,
  removeTokens,
  getAccessToken,
  getRoleFromToken,
  isRoleAllowed,
} from '../services/api';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadUser = async () => {
      const token = getAccessToken();
      if (token) {
        const role = getRoleFromToken(token);
        if (!isRoleAllowed(role)) {
          // Роль Customer – удаляем токены и не загружаем пользователя
          removeTokens();
          setLoading(false);
          return;
        }
        try {
          const response = await authApiRequest('/api/users', { method: 'GET' });
          if (response.ok) {
            const userData = await response.json();
            setUser(userData);
          } else {
            removeTokens();
          }
        } catch {
          removeTokens();
        }
      }
      setLoading(false);
    };
    loadUser();
  }, []);

  const login = async (email, password) => {
    const response = await fetch(`${process.env.REACT_APP_AUTH_API_URL}/api/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    });

    if (response.ok) {
      const data = await response.json();
      const role = getRoleFromToken(data.accessToken);
      if (!isRoleAllowed(role)) {
        // Роль Customer – не пускаем
        removeTokens();
        return { success: false, error: 'Доступ запрещён для данной роли' };
      }
      setTokens(data.accessToken, data.refreshToken);
      const userResponse = await authApiRequest('/api/users', { method: 'GET' });
      if (userResponse.ok) {
        const userData = await userResponse.json();
        setUser(userData);
        return { success: true };
      } else {
        removeTokens();
        return { success: false, error: 'Не удалось загрузить данные пользователя' };
      }
    } else {
      const errorData = await response.json().catch(() => ({}));
      return { success: false, error: errorData.message || 'Ошибка входа' };
    }
  };

  const register = async (email, password, credentials) => {
    const response = await fetch(`${process.env.REACT_APP_AUTH_API_URL}/api/auth/register`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password, credentials }),
    });

    if (response.ok) {
      return { success: true };
    } else {
      const errorData = await response.json().catch(() => ({}));
      return { success: false, error: errorData.message || 'Ошибка регистрации' };
    }
  };

  const logout = async () => {
    try {
      await authApiRequest('/api/auth/logout', { method: 'POST' });
    } finally {
      removeTokens();
      setUser(null);
    }
  };

  const updateProfile = async (data) => {
    const response = await authApiRequest('/api/users', {
      method: 'PUT',
      body: JSON.stringify(data),
    });
    if (response.ok) {
      const userResponse = await authApiRequest('/api/users', { method: 'GET' });
      const updatedUser = await userResponse.json();
      setUser(updatedUser);
      return { success: true };
    } else {
      const error = await response.json().catch(() => ({}));
      return { success: false, error: error.message || 'Ошибка обновления' };
    }
  };

  const changePassword = async (oldPassword, newPassword) => {
    const response = await authApiRequest('/api/auth/change-password', {
      method: 'POST',
      body: JSON.stringify({ oldPassword, newPassword }),
    });
    if (response.ok) {
      return { success: true };
    } else {
      const error = await response.json().catch(() => ({}));
      return { success: false, error: error.message || 'Ошибка смены пароля' };
    }
  };

  const value = {
    user,
    login,
    register,
    logout,
    updateProfile,
    changePassword,
    loading,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = () => useContext(AuthContext);
</file>

<file path="index.js">
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import 'antd/dist/reset.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="pages/accounts/AccountsPage.jsx">
import React, { useEffect, useState } from 'react';
import { Table, Tag, Button, message, Spin, Tooltip, Drawer, Space, Typography } from 'antd';
import { UserOutlined, DeleteOutlined, CloseOutlined, MoneyCollectOutlined, MinusCircleOutlined, PlusCircleOutlined } from '@ant-design/icons';
import { useAuth } from '../../context/authContext';
import { getAccounts, deleteAccount, getAccountTransactions } from '../../services/core';
import { authApiRequest } from '../../services/api';
import dayjs from 'dayjs'; // если есть, иначе использовать new Date()
import { transactionColumns } from './values/transactionTable';
import { DepositWithdrawModal } from './ui/DepositWithdrawModal';

const { Text } = Typography;

export const AccountsPage = () => {
  const [accounts, setAccounts] = useState([]);
  const [loading, setLoading] = useState(false);
  const [usersMap, setUsersMap] = useState({});
  const [selectedAccount, setSelectedAccount] = useState(null);
  const [drawerVisible, setDrawerVisible] = useState(false);
  const [transactions, setTransactions] = useState([]);
  const [transactionsLoading, setTransactionsLoading] = useState(false);

  const [modalStatus, setModalStatus] = useState(null)

  const fetchAccounts = async () => {
    setLoading(true);
    try {
      const data = await getAccounts();
      setAccounts(data);

      // Загружаем данные владельцев
      const uniqueUserIds = [...new Set(data.map(acc => acc.userId).filter(Boolean))];
      if (uniqueUserIds.length > 0) {
        const usersData = await Promise.all(
          uniqueUserIds.map(async (id) => {
            try {
              const res = await authApiRequest(`/api/users/${id}`, { method: 'GET' });
              if (res.ok) return await res.json();
            } catch {
              return null;
            }
            return null;
          })
        );
        const map = {};
        usersData.forEach(u => {
          if (u && u.id) map[u.id] = u;
        });
        setUsersMap(map);
      }
    } catch (error) {
      message.error('Не удалось загрузить счета');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchAccounts();
  }, []);

  const handleDelete = async (id, e) => {
    e.stopPropagation(); // предотвращаем открытие drawer при клике на удаление
    try {
      await deleteAccount(id);
      message.success('Счёт удалён');
      fetchAccounts();
    } catch {
      message.error('Ошибка при удалении счёта');
    }
  };

  const handleRowClick = (record) => {
    setSelectedAccount(record);
    setDrawerVisible(true);
    loadTransactions(record.id);
  };

  const loadTransactions = async (accountId) => {
    setTransactionsLoading(true);
    try {
      const data = await getAccountTransactions(accountId); // нужно добавить в core.js
      setTransactions(data);
    } catch (error) {
      message.error('Не удалось загрузить транзакции');
      setTransactions([]);
    } finally {
      setTransactionsLoading(false);
    }
  };

  const closeDrawer = () => {
    setDrawerVisible(false);
    setSelectedAccount(null);
    setTransactions([]);
  };

  const invalidate = () => {
    fetchAccounts();
    if(selectedAccount?.id)
        loadTransactions(selectedAccount?.id)
  }

  const columns = [
    {
      title: 'ID счёта',
      dataIndex: 'id',
      key: 'id',
      render: (id) => <code>{id.substring(0, 8)}...</code>,
    },
    {
      title: 'Баланс',
      dataIndex: 'balance',
      key: 'balance',
      render: (balance) => <Tag color="green">{balance} ₽</Tag>,
    },
    {
      title: 'Статус',
      key: 'status',
      render: (_, record) => {
        if (!record.closedAt) {
          return <Tag color="green">Активен</Tag>;
        } else {
          const closedDate = dayjs(record.closedAt).format('DD.MM.YYYY HH:mm');
          return <Tag color="red">Закрыт {closedDate}</Tag>;
        }
      },
    },
    {
      title: 'Владелец',
      key: 'owner',
      render: (_, record) => {
        const owner = usersMap[record.userId];
        if (!owner) return '—';
        return (
          <Tooltip title={owner.email}>
            <UserOutlined /> {owner.credentials || owner.email}
          </Tooltip>
        );
      },
    },
    {
      title: 'Действия',
      key: 'actions',
      render: (_, record) => (
        <Button
          icon={<DeleteOutlined />}
          danger
          size="small"
          onClick={(e) => handleDelete(record.id, e)}
        />
      ),
    },
  ];

  

  return (
    <div>
      <h2>Счета клиентов</h2>
      {loading ? (
        <Spin size="large" style={{ display: 'block', margin: '50px auto' }} />
      ) : (
        <Table
          dataSource={accounts}
          columns={columns}
          rowKey="id"
          pagination={{ pageSize: 10 }}
          onRow={(record) => ({
            onClick: () => handleRowClick(record),
            style: { cursor: 'pointer' },
          })}
        />
      )}

      <Drawer
        title={`Транзакции счета ${selectedAccount?.id}`}
        placement="right"
        width={800}
        onClose={closeDrawer}
        open={drawerVisible}
        extra={
          <Space>
            <Button type='primary' onClick={() => setModalStatus({open: true, type: 'deposit'})} icon={<PlusCircleOutlined/>}>Пополнить</Button>
            <Button type='default' onClick={() => setModalStatus({open: true, type: 'withdraw'})} icon={<MinusCircleOutlined/>}>Снять</Button>
          </Space>
        }
      >
        {transactionsLoading ? (
          <Spin />
        ) : (
            <Table
                dataSource={transactions}
                columns={transactionColumns(transactions, selectedAccount)}
                rowKey="id"
                pagination={{ pageSize: 20 }}
                locale={{ emptyText: 'Нет транзакций' }}
            />
        )}
      </Drawer>

      <DepositWithdrawModal 
        accountId={selectedAccount?.id}
        onInvalidate={invalidate}
        open={modalStatus?.open ?? false}
        type={modalStatus?.type ?? 'withdraw'}
        onClose={() => setModalStatus(null)}
      />
    </div>
  );
};
</file>

<file path="pages/accounts/ui/DepositWithdrawModal.jsx">
import { Modal, Form, Input, InputNumber, Button, message } from 'antd';
import { useSubmit } from 'react-router-dom';
import { useEffect } from 'react';
import { deposit, withdraw } from '../../../services/core';

export const DepositWithdrawModal = ({ open, onClose, onInvalidate, type, accountId }) => {
  const [form] = Form.useForm();

  // Reset form when modal opens/closes or type changes
  useEffect(() => {
    if (open) {
      form.resetFields();
    }
  }, [open, form]);

  const handleFinish = async (values) => {
    const req = type == "deposit" ? deposit : withdraw;

    try{
        var json = await req(accountId, values);
    } catch (e) {
        message.error({ content: e.message })
    }
    onInvalidate();
    onClose();
  };

  const title = type === 'deposit' ? 'Пополнение счета' : 'Снятие со счета';
  const okText = type === 'deposit' ? 'Пополнить' : 'Снять';

  return (
    <Modal
      open={open}
      title={title}
      onCancel={onClose}
      footer={null} // We'll use the form's own buttons
      destroyOnClose
    >
      <Form
        form={form}
        layout="vertical"
        onFinish={handleFinish}
        initialValues={{ amount: undefined, description: '' }}
      >
        <Form.Item
          name="amount"
          label="Сумма"
          rules={[
            { required: true, message: 'Введите сумму' },
            { type: 'number', min: 0.01, message: 'Сумма должна быть больше 0' },
          ]}
        >
          <InputNumber
            style={{ width: '100%' }}
            placeholder="0.00"
            precision={2}
            step={0.01}
            min={0.01}
          />
        </Form.Item>

        <Form.Item
          name="description"
          label="Описание (необязательно)"
        >
          <Input.TextArea rows={3} placeholder="Введите описание транзакции" />
        </Form.Item>

        <Form.Item style={{ marginBottom: 0, textAlign: 'right' }}>
          <Button onClick={onClose} style={{ marginRight: 8 }}>
            Отмена
          </Button>
          <Button type="primary" htmlType="submit">
            {okText}
          </Button>
        </Form.Item>
      </Form>
    </Modal>
  );
};
</file>

<file path="pages/accounts/values/transactionTable.js">
import { Tag } from 'antd';
import dayjs from 'dayjs';


const typeMap = {
    Unclassified: "неклассифицировано",
    Deposit: "Пополнение ч/з банкомат",
    Withdrawal: "Снятие ч/з банкомат",
    Transfer: "Перевод",
    CreditPayment: "Выплата кредита",
    CreditIncoming: "Взятие кредита"
}

// Колонки для таблицы транзакций с фильтрами
export const transactionColumns = (data, selectedAccount) => {
    // Вычисляем уникальные значения для фильтров
const typeFilters = [...new Set(data.map(t => t.displayType))]
  .map(type => ({
    text: typeMap[type] || type,
    value: type
  }));

const statusFilters = [...new Set(data.map(t => t.status))]
  .map(status => ({
    text: status,
    value: status
  }));
return[
  {
    title: 'Дата',
    dataIndex: 'createdAt',
    key: 'createdAt',
    render: (date) => dayjs(date).format('DD.MM.YYYY HH:mm'),
    // Можно добавить фильтр по дате с помощью filterDropdown,
    // но для простоты здесь не реализовано
  },
  {
    title: 'Тип',
    dataIndex: 'displayType', 
    key: 'type',
    render: (type) => typeMap[type] || typeMap.Unclassified,
    filters: typeFilters,       // массив объектов { text, value }
    onFilter: (value, record) => record.type === value,
  },
  {
    title: 'Сумма',
    dataIndex: 'amount',
    key: 'amount',
    render: (amount, record) => (
      <Tag color={record.targetId == selectedAccount.id ? 'green' : 'red'}>
        {record.targetId == selectedAccount.id ? '+' : '-'} {amount} ₽
      </Tag>
    ),
    // Для числовых фильтров можно использовать filterDropdown с RangePicker,
    // но здесь не реализовано для краткости
  },
  {
    title: 'Описание',
    dataIndex: 'description',
    key: 'description',
    // Можно добавить текстовый поиск через глобальный поиск таблицы,
    // либо через filterDropdown с Input.Search
  },
  {
    title: 'Статус',
    dataIndex: 'status',
    key: 'status',
    render: (status) => (
      <Tag color={{ Pending: 'yellow', Completed: 'green', Failed: 'red' }[status]}>
        {status}
      </Tag>
    ),
    filters: statusFilters,
    onFilter: (value, record) => record.status === value,
  },
]};
</file>

<file path="pages/forbidden/ForbiddenPage.jsx">
import React from 'react';
import { Result, Button } from 'antd';
import { Link } from 'react-router-dom';
import { useAuth } from '../../context/authContext';

export const ForbiddenPage = () => {
  const { logout } = useAuth();
  return (
    <Result
      status="403"
      title="403"
      subTitle="Извините, у вас нет доступа к этой странице."
      extra={[
        <Button type="primary" key="home">
          <Link to="/">На главную</Link>
        </Button>,
        <Button key="logout" onClick={logout}>
          Выйти
        </Button>,
      ]}
    />
  );
};
</file>

<file path="pages/home/HomePage.jsx">
import React from 'react';
import { Typography } from 'antd';
import { useAuth } from '../../context/authContext';

const { Title, Paragraph } = Typography;

export const HomePage = () => {
  const { user } = useAuth();
  return (
    <div>
      <Title>Добро пожаловать, {user?.credentials}!</Title>
      <Paragraph>
        Это главная страница, доступная только авторизованным пользователям.
      </Paragraph>
    </div>
  );
};
</file>

<file path="pages/login/LoginPage.jsx">
import React from 'react';
import { Form, Input, Button, Card, message } from 'antd';
import { UserOutlined, LockOutlined } from '@ant-design/icons';
import { Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/authContext';

export const LoginPage = () => {
  const navigate = useNavigate();
  const { login } = useAuth();

  const onFinish = async (values) => {
    const { email, password } = values;
    const result = await login(email, password);
    if (result.success) {
      message.success('Вход выполнен успешно');
      navigate('/');
    } else {
      message.error(result.error || 'Ошибка входа');
    }
  };

  return (
    <div style={{ display: 'flex', justifyContent: 'center', marginTop: '50px' }}>
      <Card title="Вход в систему" style={{ width: 400 }}>
        <Form name="login" onFinish={onFinish} autoComplete="off">
          <Form.Item
            name="email"
            rules={[
              { required: true, message: 'Введите email' },
              { type: 'email', message: 'Некорректный email' },
            ]}
          >
            <Input prefix={<UserOutlined />} placeholder="Email" />
          </Form.Item>

          <Form.Item
            name="password"
            rules={[{ required: true, message: 'Введите пароль' }]}
          >
            <Input.Password prefix={<LockOutlined />} placeholder="Пароль" />
          </Form.Item>

          <Form.Item>
            <Button type="primary" htmlType="submit" block>
              Войти
            </Button>
          </Form.Item>
        </Form>
      </Card>
    </div>
  );
};
</file>

<file path="pages/notFound/NotFoundPage.jsx">
import React from 'react';
import { Result, Button } from 'antd';
import { Link } from 'react-router-dom';

export const NotFoundPage = () => {
  return (
    <Result
      status="404"
      title="404"
      subTitle="Извините, страница не найдена."
      extra={<Button type="primary"><Link to="/">Вернуться на главную</Link></Button>}
    />
  );
};
</file>

<file path="pages/profile/ProfilePage.jsx">
import React, { useState } from 'react';
import { Typography, Card, Button, Form, Input, message, Tabs } from 'antd';
import { useAuth } from '../../context/authContext';

const { Title, Text } = Typography;
const { TabPane } = Tabs;

export const ProfilePage = () => {
  const { user, logout, updateProfile, changePassword } = useAuth();
  const [profileForm] = Form.useForm();
  const [passwordForm] = Form.useForm();
  const [updating, setUpdating] = useState(false);
  const [changing, setChanging] = useState(false);

  const handleUpdateProfile = async (values) => {
    setUpdating(true);
    const result = await updateProfile(values);
    setUpdating(false);
    if (result.success) {
      message.success('Профиль обновлён');
    } else {
      message.error(result.error);
    }
  };

  const handleChangePassword = async (values) => {
    setChanging(true);
    const result = await changePassword(values.oldPassword, values.newPassword);
    setChanging(false);
    if (result.success) {
      message.success('Пароль изменён');
      passwordForm.resetFields();
    } else {
      message.error(result.error);
    }
  };

  return (
    <Card style={{ maxWidth: 600, margin: '0 auto' }}>
      <Title level={2}>Профиль</Title>
      <Tabs defaultActiveKey="1">
        <TabPane tab="Основное" key="1">
          <div style={{ marginBottom: 20 }}>
            <Text strong>Email: </Text> <Text>{user?.email}</Text><br />
            <Text strong>Имя: </Text> <Text>{user?.credentials}</Text>
          </div>
          <Form
            form={profileForm}
            layout="vertical"
            onFinish={handleUpdateProfile}
            initialValues={{ email: user?.email, credentials: user?.credentials }}
          >
            <Form.Item
              name="email"
              label="Email"
              rules={[{ required: true, type: 'email', message: 'Введите корректный email' }]}
            >
              <Input />
            </Form.Item>
            <Form.Item
              name="credentials"
              label="Имя"
              rules={[{ required: true, message: 'Введите имя' }]}
            >
              <Input />
            </Form.Item>
            <Form.Item>
              <Button type="primary" htmlType="submit" loading={updating}>
                Обновить профиль
              </Button>
            </Form.Item>
          </Form>
        </TabPane>
        <TabPane tab="Смена пароля" key="2">
          <Form
            form={passwordForm}
            layout="vertical"
            onFinish={handleChangePassword}
          >
            <Form.Item
              name="oldPassword"
              label="Старый пароль"
              rules={[{ required: true, message: 'Введите старый пароль' }]}
            >
              <Input.Password />
            </Form.Item>
            <Form.Item
              name="newPassword"
              label="Новый пароль"
              rules={[{ required: true, message: 'Введите новый пароль' }]}
            >
              <Input.Password />
            </Form.Item>
            <Form.Item>
              <Button type="primary" htmlType="submit" loading={changing}>
                Сменить пароль
              </Button>
            </Form.Item>
          </Form>
        </TabPane>
      </Tabs>
      <div style={{ marginTop: 20 }}>
        <Button type="primary" danger onClick={logout}>
          Выйти
        </Button>
      </div>
    </Card>
  );
};
</file>

<file path="services/api.js">
// services/api.js
import { jwtDecode } from 'jwt-decode';

// Функции для работы с токенами (общие)
const getAccessToken = () => localStorage.getItem('accessToken');
const getRefreshToken = () => localStorage.getItem('refreshToken');

const setTokens = (accessToken, refreshToken) => {
  localStorage.setItem('accessToken', accessToken);
  if (refreshToken) localStorage.setItem('refreshToken', refreshToken);
};

const removeTokens = () => {
  localStorage.removeItem('accessToken');
  localStorage.removeItem('refreshToken');
};

const getRoleFromToken = (token) => {
  try {
    const decoded = jwtDecode(token);
    return decoded.role; // предполагается поле "role"
  } catch {
    return null;
  }
};

const isRoleAllowed = (role) => role !== 'Customer';

// Фабрика для создания API-клиента с заданным baseURL
const createApiRequest = (baseURL) => {
  return async function apiRequest(endpoint, options = {}) {
    const url = `${baseURL}${endpoint}`;
    const accessToken = getAccessToken();

    const headers = {
      'Content-Type': 'application/json',
      ...options.headers,
    };

    if (accessToken) {
      headers.Authorization = `Bearer ${accessToken}`;
    }

    let response = await fetch(url, { ...options, headers });

    // Попытка обновить токен при 401
    if (response.status === 401 && getRefreshToken()) {
      const newTokens = await refreshAccessToken();
      if (newTokens) {
        headers.Authorization = `Bearer ${newTokens.accessToken}`;
        response = await fetch(url, { ...options, headers });
      } else {
        removeTokens();
        window.location.href = '/login';
        throw new Error('Session expired');
      }
    }

    return response;
  };
};

// Функция обновления токена (использует baseURL Auth, так как endpoint принадлежит Auth)
async function refreshAccessToken() {
  const refreshToken = getRefreshToken();
  if (!refreshToken) return null;

  const authBaseURL = process.env.REACT_APP_AUTH_API_URL || 'http://localhost:5000';
  try {
    const response = await fetch(`${authBaseURL}/api/auth/refresh?token=${refreshToken}`, {
      method: 'POST',
    });
    if (response.ok) {
      const data = await response.json();
      setTokens(data.accessToken, data.refreshToken || refreshToken);
      return { accessToken: data.accessToken };
    } else {
      removeTokens();
      return null;
    }
  } catch {
    removeTokens();
    return null;
  }
}

// Создаём два экземпляра: для Auth и для Core
const authApiRequest = createApiRequest(process.env.REACT_APP_AUTH_API_URL || 'http://localhost:5000');
const coreApiRequest = createApiRequest(process.env.REACT_APP_CORE_API_URL || 'http://localhost:5001');

export {
  authApiRequest,
  coreApiRequest,
  setTokens,
  removeTokens,
  getAccessToken,
  getRefreshToken,
  getRoleFromToken,
  isRoleAllowed,
};
</file>

<file path="services/core.js">
// services/core.js
import { coreApiRequest } from './api';

export const getAccounts = async () => {
  const response = await coreApiRequest('/api/accounts/employee', { method: 'GET' });
  if (!response.ok) {
    throw new Error('Failed to fetch accounts');
  }
  return response.json(); // предполагаем, что возвращается массив объектов AccountDto
};

export const getAccountById = async (id) => {
  const response = await coreApiRequest(`/api/accounts/employee/${id}`, { method: 'GET' });
  if (!response.ok) {
    throw new Error('Failed to fetch account');
  }
  return response.json();
};

export const deleteAccount = async (id) => {
  const response = await coreApiRequest(`/api/accounts/employee/${id}`, { method: 'DELETE' });
  if (!response.ok) {
    throw new Error('Failed to delete account');
  }
  return response.json();
};

export const deposit = async (id, { amount, description }) => {
    const body = {
        sourceId: null,
        sourceType: "RealWorld",
        targetId: id,
        targetType: "Account",
        amount,
        description
    }

  const response = await coreApiRequest(`/api/transactions`, { method: 'POST', body: JSON.stringify(body)  });
  if (!response.ok) {
    throw new Error('Failed to deposit');
  }
  return response.json();
};

export const withdraw = async (id, { amount, description }) => {
    const body = {
        sourceId: id,
        sourceType: "Account",
        targetId: null,
        targetType: "RealWorld",
        amount,
        description
    }

  const response = await coreApiRequest(`/api/transactions`, { method: 'POST', body: JSON.stringify(body)  });
  if (!response.ok) {
    throw new Error('Failed to deposit');
  }
  return response.json();
};

export const getAccountTransactions = async (accountId, from, to) => {
  let url = `/api/accounts/employee/${accountId}/transactions`;
  const params = new URLSearchParams();
  if (from) params.append('from', from.toISOString());
  if (to) params.append('to', to.toISOString());
  if (params.toString()) url += `?${params.toString()}`;
  
  const response = await coreApiRequest(url, { method: 'GET' });
  if (!response.ok) {
    throw new Error('Failed to fetch transactions');
  }
  return response.json();
};
</file>

</files>
