This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
App.js
components/layout/AppLayout.jsx
components/privateRoute/PrivateRoute.jsx
components/publicRoute/PublicRoute.jsx
context/authContext.js
index.js
pages/accounts/AccountsPage.jsx
pages/accounts/ui/DepositWithdrawModal.jsx
pages/accounts/values/transactionTable.js
pages/forbidden/ForbiddenPage.jsx
pages/home/HomePage.jsx
pages/login/LoginPage.jsx
pages/notFound/NotFoundPage.jsx
pages/profile/ProfilePage.jsx
pages/tariffs/TariffsPage.jsx
pages/users/UsersPage.jsx
services/api.js
services/core.js
services/credit.js
services/users.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="App.js">
import React from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { AuthProvider, useAuth } from './context/authContext';
import { PrivateRoute } from './components/privateRoute/PrivateRoute';
import { PublicRoute } from './components/publicRoute/PublicRoute';
import { AppLayout } from './components/layout/AppLayout';
import { HomePage } from './pages/home/HomePage';
import { LoginPage } from './pages/login/LoginPage';
import { ProfilePage } from './pages/profile/ProfilePage';
import { NotFoundPage } from './pages/notFound/NotFoundPage';
import { Spin } from 'antd'; // для индикатора загрузки
import { ForbiddenPage } from './pages/forbidden/ForbiddenPage';
import { AccountsPage } from './pages/accounts/AccountsPage';
import { UsersPage } from './pages/users/UsersPage';
import { TariffsPage } from './pages/tariffs/TariffsPage';

function AppRoutes() {
  const { loading } = useAuth();
  if (loading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', marginTop: 100 }}>
        <Spin size="large" />
      </div>
    );
  }
  return (
    <Routes>
      <Route
        path="/"
        element={
          <PrivateRoute>
            <HomePage />
          </PrivateRoute>
        }
      />
      <Route
        path="/login"
        element={
          <PublicRoute>
            <LoginPage />
          </PublicRoute>
        }
      />
      <Route
        path="/profile"
        element={
          <PrivateRoute>
            <ProfilePage />
          </PrivateRoute>
        }
      />
      <Route
        path="/accounts"
        element={
          <PrivateRoute>
            <AccountsPage />
          </PrivateRoute>
        }
      />
      <Route
        path="/users"
        element={
          <PrivateRoute>
            <UsersPage />
          </PrivateRoute>
        }
      />
      <Route
        path="/tariffs"
        element={
          <PrivateRoute>
            <TariffsPage />
          </PrivateRoute>
        }
      />
      <Route path="/forbidden" element={<ForbiddenPage/>} />
      <Route path="*" element={<NotFoundPage />} />
    </Routes>
  );
}

function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        <AppLayout>
          <AppRoutes />
        </AppLayout>
      </BrowserRouter>
    </AuthProvider>
  );
}

export default App;
</file>

<file path="components/layout/AppLayout.jsx">
import React from 'react';
import { Layout, Menu } from 'antd';
import { Link, useLocation } from 'react-router-dom';
import { useAuth } from '../../context/authContext';
import { AccountBookOutlined, ContactsOutlined, CreditCardOutlined, ExceptionOutlined, HomeOutlined, ProfileOutlined } from '@ant-design/icons';

const { Header, Content, Footer } = Layout;

export const AppLayout = ({ children }) => {
  const location = useLocation();
  const { user, logout } = useAuth();

  // Если страница логина – показываем только содержимое (без шапки и футера)
  if (location.pathname === '/login') {
    return <>{children}</>;
  }

  const menuItems = [
    { key: '/', icon: <HomeOutlined/>, label: <Link to="/">Главная</Link> },
    { key: '/users', icon: <ContactsOutlined/>, label: <Link to="/users">Пользователи</Link> },
    { key: '/accounts', icon: <AccountBookOutlined/>, label: <Link to="/accounts">Счета</Link> },
    { key: '/tariffs', icon: <CreditCardOutlined />, label: <Link to="/tariffs">Тарифы</Link> },
    user ? { key: '/profile', icon: <ProfileOutlined/>, label: <Link to="/profile">Профиль</Link> } : null,
    user
      ? { key: 'logout', icon: <ExceptionOutlined/>, label: <span onClick={logout}>Выйти</span> }
      : { key: '/login', label: <Link to="/login">Вход</Link> },
  ].filter(Boolean);

  return (
    <Layout className="layout" style={{ minHeight: '100vh' }}>
      <Header>
        <div className="logo" style={{ float: 'left', color: '#fff', marginRight: 20 }}>
          Банк 
        </div>
        <Menu
          theme="dark"
          mode="horizontal"
          selectedKeys={[location.pathname]}
          items={menuItems}
        />
      </Header>
      <Content style={{ padding: '0 50px', marginTop: 20 }}>
        <div className="site-layout-content" style={{ background: '#fff', padding: 24, minHeight: 280 }}>
          {children}
        </div>
      </Content>
      <Footer style={{ textAlign: 'center' }}>Банк</Footer>
    </Layout>
  );
};
</file>

<file path="components/privateRoute/PrivateRoute.jsx">
import React from 'react';
import { Navigate } from 'react-router-dom';
import { getAccessToken, getRoleFromToken, isRoleAllowed } from '../../services/api';

export const PrivateRoute = ({ children }) => {
  const token = getAccessToken();

  if (!token) {
    return <Navigate to="/login" />;
  }

  const role = getRoleFromToken(token);
  if (!isRoleAllowed(role)) {
    return <Navigate to="/forbidden" />;
  }

  return children;
};
</file>

<file path="components/publicRoute/PublicRoute.jsx">
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../../context/authContext';

export const PublicRoute = ({ children }) => {
  const { user } = useAuth();
  // Если пользователь уже авторизован – перенаправляем на главную
  return user ? <Navigate to="/" /> : children;
};
</file>

<file path="context/authContext.js">
import React, { createContext, useState, useContext, useEffect } from 'react';
import {
  authApiRequest,
  setTokens,
  removeTokens,
  getAccessToken,
  getRoleFromToken,
  isRoleAllowed,
} from '../services/api';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadUser = async () => {
      const token = getAccessToken();
      if (token) {
        const role = getRoleFromToken(token);
        if (!isRoleAllowed(role)) {
          // Роль Customer – удаляем токены и не загружаем пользователя
          removeTokens();
          setLoading(false);
          return;
        }
        try {
          const response = await authApiRequest('/api/users', { method: 'GET' });
          if (response.ok) {
            const userData = await response.json();
            setUser(userData);
          } else {
            removeTokens();
          }
        } catch {
          removeTokens();
        }
      }
      setLoading(false);
    };
    loadUser();
  }, []);

  const login = async (email, password) => {
    const response = await fetch(`${process.env.REACT_APP_AUTH_API_URL}/api/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    });

    if (response.ok) {
      const data = await response.json();
      const role = getRoleFromToken(data.accessToken);
      if (!isRoleAllowed(role)) {
        // Роль Customer – не пускаем
        removeTokens();
        return { success: false, error: 'Доступ запрещён для данной роли' };
      }
      setTokens(data.accessToken, data.refreshToken);
      const userResponse = await authApiRequest('/api/users', { method: 'GET' });
      if (userResponse.ok) {
        const userData = await userResponse.json();
        setUser(userData);
        return { success: true };
      } else {
        removeTokens();
        return { success: false, error: 'Не удалось загрузить данные пользователя' };
      }
    } else {
      const errorData = await response.json().catch(() => ({}));
      return { success: false, error: errorData.message || 'Ошибка входа' };
    }
  };

  const register = async (email, password, credentials) => {
    const response = await fetch(`${process.env.REACT_APP_AUTH_API_URL}/api/auth/register`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password, credentials }),
    });

    if (response.ok) {
      return { success: true };
    } else {
      const errorData = await response.json().catch(() => ({}));
      return { success: false, error: errorData.message || 'Ошибка регистрации' };
    }
  };

  const logout = async () => {
    try {
      await authApiRequest('/api/auth/logout', { method: 'POST' });
    } finally {
      removeTokens();
      setUser(null);
    }
  };

  const updateProfile = async (data) => {
    const response = await authApiRequest('/api/users', {
      method: 'PUT',
      body: JSON.stringify(data),
    });
    if (response.ok) {
      const userResponse = await authApiRequest('/api/users', { method: 'GET' });
      const updatedUser = await userResponse.json();
      setUser(updatedUser);
      return { success: true };
    } else {
      const error = await response.json().catch(() => ({}));
      return { success: false, error: error.message || 'Ошибка обновления' };
    }
  };

  const changePassword = async (oldPassword, newPassword) => {
    const response = await authApiRequest('/api/auth/change-password', {
      method: 'POST',
      body: JSON.stringify({ oldPassword, newPassword }),
    });
    if (response.ok) {
      return { success: true };
    } else {
      const error = await response.json().catch(() => ({}));
      return { success: false, error: error.message || 'Ошибка смены пароля' };
    }
  };

  const value = {
    user,
    login,
    register,
    logout,
    updateProfile,
    changePassword,
    loading,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = () => useContext(AuthContext);
</file>

<file path="index.js">
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import 'antd/dist/reset.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="pages/accounts/AccountsPage.jsx">
import React, { useEffect, useState } from 'react';
import { Table, Tag, Button, message, Spin, Tooltip, Drawer, Space, Typography, Popconfirm } from 'antd';
import { UserOutlined, DeleteOutlined, CloseOutlined, MoneyCollectOutlined, MinusCircleOutlined, PlusCircleOutlined, BlockOutlined, EyeFilled, EyeOutlined, BookOutlined } from '@ant-design/icons';
import { useAuth } from '../../context/authContext';
import { getAccounts, deleteAccount, getAccountTransactions } from '../../services/core';
import { authApiRequest } from '../../services/api';
import dayjs from 'dayjs'; // если есть, иначе использовать new Date()
import { transactionColumns } from './values/transactionTable';
import { DepositWithdrawModal } from './ui/DepositWithdrawModal';

const { Text } = Typography;

export const AccountsPage = () => {
  const [accounts, setAccounts] = useState([]);
  const [loading, setLoading] = useState(false);
  const [usersMap, setUsersMap] = useState({});
  const [selectedAccount, setSelectedAccount] = useState(null);
  const [drawerVisible, setDrawerVisible] = useState(false);
  const [transactions, setTransactions] = useState([]);
  const [transactionsLoading, setTransactionsLoading] = useState(false);

  const [modalStatus, setModalStatus] = useState(null)

  const fetchAccounts = async () => {
    setLoading(true);
    try {
      const data = await getAccounts();
      setAccounts(data);

      // Загружаем данные владельцев
      const uniqueUserIds = [...new Set(data.map(acc => acc.userId).filter(Boolean))];
      if (uniqueUserIds.length > 0) {
        const usersData = await Promise.all(
          uniqueUserIds.map(async (id) => {
            try {
              const res = await authApiRequest(`/api/users/${id}`, { method: 'GET' });
              if (res.ok) return await res.json();
            } catch {
              return null;
            }
            return null;
          })
        );
        const map = {};
        usersData.forEach(u => {
          if (u && u.id) map[u.id] = u;
        });
        setUsersMap(map);
      }
    } catch (error) {
      message.error('Не удалось загрузить счета');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchAccounts();
  }, []);

  const handleDelete = async (id, e) => {
    e.stopPropagation(); // предотвращаем открытие drawer при клике на удаление
    try {
      await deleteAccount(id);
      message.success('Счёт удалён');
    } catch (e){
      message.error('Ошибка при удалении счёта: ' + e.message);
    }
      fetchAccounts();
  };

  const handleRowClick = (record) => {
    setSelectedAccount(record);
    setDrawerVisible(true);
    loadTransactions(record.id);
  };

  const loadTransactions = async (accountId) => {
    setTransactionsLoading(true);
    try {
      const data = await getAccountTransactions(accountId); // нужно добавить в core.js
      setTransactions(data);
    } catch (error) {
      message.error('Не удалось загрузить транзакции');
      setTransactions([]);
    } finally {
      setTransactionsLoading(false);
    }
  };

  const closeDrawer = () => {
    setDrawerVisible(false);
    setSelectedAccount(null);
    setTransactions([]);
  };

  const invalidate = () => {
    fetchAccounts();
    if(selectedAccount?.id)
        loadTransactions(selectedAccount?.id)
  }

  const columns = [
    {
      title: 'ID счёта',
      dataIndex: 'id',
      key: 'id',
      render: (id) => <code>{id.substring(0, 8)}...</code>,
    },
    {
      title: 'Баланс',
      dataIndex: 'balance',
      key: 'balance',
      render: (balance) => <Tag color="green">{balance} ₽</Tag>,
    },
    {
      title: 'Статус',
      key: 'status',
      render: (_, record) => {
        if (!record.closedAt && !record.isDeleted) {
          return <Tag color="green">Активен</Tag>;
        } else if(record.closedAt) {
          const closedDate = dayjs(record.closedAt).format('DD.MM.YYYY HH:mm');
          return <Tag color="red">Закрыт {closedDate}</Tag>;
        }else if(record.isDeleted) {
          return <Tag color="red">Пользователь заблокирован</Tag>;
        }
      },
    },
    {
      title: 'Владелец',
      key: 'owner',
      render: (_, record) => {
        const owner = usersMap[record.userId];
        if (!owner) return '—';
        return (
          <Tooltip title={owner.email}>
            <UserOutlined /> {owner.credentials || owner.email}
          </Tooltip>
        );
      },
    },
    {
      title: 'Действия',
      key: 'actions',
      render: (_, record) => (
        <Space>
            <Button
                icon={<BookOutlined />}
                type='default'
                size="small"
                onClick={() => handleRowClick(record)}
            >История операций</Button>
            {!record.closedAt && !record.isDeleted && <Popconfirm 
            title="Подтвердите действие"
            description="Вы уверены что хотите закрыть этот счёт?"
            okText="Закрыть"
            cancelText="Отмена"
            onConfirm={(e) => handleDelete(record.id, e)}>
                <Button
                    icon={<DeleteOutlined />}
                    danger
                    size="small"
                >Закрыть</Button>
            </Popconfirm> }
        </Space>
      ),
    },
  ];

  

  return (
    <div>
      <h2>Счета клиентов</h2>
      {loading ? (
        <Spin size="large" style={{ display: 'block', margin: '50px auto' }} />
      ) : (
        <Table
          dataSource={accounts}
          columns={columns}
          rowKey="id"
          pagination={{ pageSize: 10 }}
        />
      )}

      <Drawer
        title={`Транзакции счета ${selectedAccount?.id}`}
        placement="right"
        width={800}
        onClose={closeDrawer}
        open={drawerVisible}
        extra={
          <Space>
            <Button type='primary' onClick={() => setModalStatus({open: true, type: 'deposit'})} icon={<PlusCircleOutlined/>}>Пополнить</Button>
            <Button type='default' onClick={() => setModalStatus({open: true, type: 'withdraw'})} icon={<MinusCircleOutlined/>}>Снять</Button>
          </Space>
        }
      >
        {transactionsLoading ? (
          <Spin />
        ) : (
            <Table
                dataSource={transactions}
                columns={transactionColumns(transactions, selectedAccount)}
                rowKey="id"
                pagination={{ pageSize: 20 }}
                locale={{ emptyText: 'Нет транзакций' }}
            />
        )}
      </Drawer>

      <DepositWithdrawModal 
        accountId={selectedAccount?.id}
        onInvalidate={invalidate}
        open={modalStatus?.open ?? false}
        type={modalStatus?.type ?? 'withdraw'}
        onClose={() => setModalStatus(null)}
      />
    </div>
  );
};
</file>

<file path="pages/accounts/ui/DepositWithdrawModal.jsx">
import { Modal, Form, Input, InputNumber, Button, message } from 'antd';
import { useSubmit } from 'react-router-dom';
import { useEffect } from 'react';
import { deposit, withdraw } from '../../../services/core';

export const DepositWithdrawModal = ({ open, onClose, onInvalidate, type, accountId }) => {
  const [form] = Form.useForm();

  // Reset form when modal opens/closes or type changes
  useEffect(() => {
    if (open) {
      form.resetFields();
    }
  }, [open, form]);

  const handleFinish = async (values) => {
    const req = type == "deposit" ? deposit : withdraw;

    try{
        var json = await req(accountId, values);
    } catch (e) {
        message.error({ content: e.message })
    }
    onInvalidate();
    onClose();
  };

  const title = type === 'deposit' ? 'Пополнение счета' : 'Снятие со счета';
  const okText = type === 'deposit' ? 'Пополнить' : 'Снять';

  return (
    <Modal
      open={open}
      title={title}
      onCancel={onClose}
      footer={null} // We'll use the form's own buttons
      destroyOnClose
    >
      <Form
        form={form}
        layout="vertical"
        onFinish={handleFinish}
        initialValues={{ amount: undefined, description: '' }}
      >
        <Form.Item
          name="amount"
          label="Сумма"
          rules={[
            { required: true, message: 'Введите сумму' },
            { type: 'number', min: 0.01, message: 'Сумма должна быть больше 0' },
          ]}
        >
          <InputNumber
            style={{ width: '100%' }}
            placeholder="0.00"
            precision={2}
            step={0.01}
            min={0.01}
          />
        </Form.Item>

        <Form.Item
          name="description"
          label="Описание (необязательно)"
        >
          <Input.TextArea rows={3} placeholder="Введите описание транзакции" />
        </Form.Item>

        <Form.Item style={{ marginBottom: 0, textAlign: 'right' }}>
          <Button onClick={onClose} style={{ marginRight: 8 }}>
            Отмена
          </Button>
          <Button type="primary" htmlType="submit">
            {okText}
          </Button>
        </Form.Item>
      </Form>
    </Modal>
  );
};
</file>

<file path="pages/accounts/values/transactionTable.js">
import { Tag } from 'antd';
import dayjs from 'dayjs';


const typeMap = {
    Unclassified: "неклассифицировано",
    Deposit: "Пополнение ч/з банкомат",
    Withdrawal: "Снятие ч/з банкомат",
    Transfer: "Перевод",
    CreditPayment: "Выплата кредита",
    CreditIncoming: "Взятие кредита"
}

// Колонки для таблицы транзакций с фильтрами
export const transactionColumns = (data, selectedAccount) => {
    // Вычисляем уникальные значения для фильтров
const typeFilters = [...new Set(data.map(t => t.displayType))]
  .map(type => ({
    text: typeMap[type] || type,
    value: type
  }));

const statusFilters = [...new Set(data.map(t => t.status))]
  .map(status => ({
    text: status,
    value: status
  }));
return[
  {
    title: 'Дата',
    dataIndex: 'createdAt',
    key: 'createdAt',
    render: (date) => dayjs(date).format('DD.MM.YYYY HH:mm'),
    // Можно добавить фильтр по дате с помощью filterDropdown,
    // но для простоты здесь не реализовано
  },
  {
    title: 'Тип',
    dataIndex: 'displayType', 
    key: 'type',
    render: (type) => typeMap[type] || typeMap.Unclassified,
    filters: typeFilters,       // массив объектов { text, value }
    onFilter: (value, record) => record.type === value,
  },
  {
    title: 'Сумма',
    dataIndex: 'amount',
    key: 'amount',
    render: (amount, record) => (
      <Tag color={record.targetId == selectedAccount.id ? 'green' : 'red'}>
        {record.targetId == selectedAccount.id ? '+' : '-'} {amount} ₽
      </Tag>
    ),
    // Для числовых фильтров можно использовать filterDropdown с RangePicker,
    // но здесь не реализовано для краткости
  },
  {
    title: 'Описание',
    dataIndex: 'description',
    key: 'description',
    // Можно добавить текстовый поиск через глобальный поиск таблицы,
    // либо через filterDropdown с Input.Search
  },
  {
    title: 'Статус',
    dataIndex: 'status',
    key: 'status',
    render: (status) => (
      <Tag color={{ Pending: 'yellow', Completed: 'green', Failed: 'red' }[status]}>
        {status}
      </Tag>
    ),
    filters: statusFilters,
    onFilter: (value, record) => record.status === value,
  },
]};
</file>

<file path="pages/forbidden/ForbiddenPage.jsx">
import React from 'react';
import { Result, Button } from 'antd';
import { Link } from 'react-router-dom';
import { useAuth } from '../../context/authContext';

export const ForbiddenPage = () => {
  const { logout } = useAuth();
  return (
    <Result
      status="403"
      title="403"
      subTitle="Извините, у вас нет доступа к этой странице."
      extra={[
        <Button type="primary" key="home">
          <Link to="/">На главную</Link>
        </Button>,
        <Button key="logout" onClick={logout}>
          Выйти
        </Button>,
      ]}
    />
  );
};
</file>

<file path="pages/home/HomePage.jsx">
import React from 'react';
import { Typography } from 'antd';
import { useAuth } from '../../context/authContext';

const { Title, Paragraph } = Typography;

export const HomePage = () => {
  const { user } = useAuth();
  return (
    <div>
      <Title>Добро пожаловать, {user?.credentials}!</Title>
      <Paragraph>
        Это главная страница, доступная только авторизованным пользователям.
      </Paragraph>
    </div>
  );
};
</file>

<file path="pages/login/LoginPage.jsx">
import React from 'react';
import { Form, Input, Button, Card, message } from 'antd';
import { UserOutlined, LockOutlined } from '@ant-design/icons';
import { Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/authContext';

export const LoginPage = () => {
  const navigate = useNavigate();
  const { login } = useAuth();

  const onFinish = async (values) => {
    const { email, password } = values;
    const result = await login(email, password);
    if (result.success) {
      message.success('Вход выполнен успешно');
      navigate('/');
    } else {
      message.error(result.error || 'Ошибка входа');
    }
  };

  return (
    <div style={{ display: 'flex', justifyContent: 'center', marginTop: '50px' }}>
      <Card title="Вход в систему" style={{ width: 400 }}>
        <Form name="login" onFinish={onFinish} autoComplete="off">
          <Form.Item
            name="email"
            rules={[
              { required: true, message: 'Введите email' },
              { type: 'email', message: 'Некорректный email' },
            ]}
          >
            <Input prefix={<UserOutlined />} placeholder="Email" />
          </Form.Item>

          <Form.Item
            name="password"
            rules={[{ required: true, message: 'Введите пароль' }]}
          >
            <Input.Password prefix={<LockOutlined />} placeholder="Пароль" />
          </Form.Item>

          <Form.Item>
            <Button type="primary" htmlType="submit" block>
              Войти
            </Button>
          </Form.Item>
        </Form>
      </Card>
    </div>
  );
};
</file>

<file path="pages/notFound/NotFoundPage.jsx">
import React from 'react';
import { Result, Button } from 'antd';
import { Link } from 'react-router-dom';

export const NotFoundPage = () => {
  return (
    <Result
      status="404"
      title="404"
      subTitle="Извините, страница не найдена."
      extra={<Button type="primary"><Link to="/">Вернуться на главную</Link></Button>}
    />
  );
};
</file>

<file path="pages/profile/ProfilePage.jsx">
import React, { useState } from 'react';
import { Typography, Card, Button, Form, Input, message, Tabs } from 'antd';
import { useAuth } from '../../context/authContext';

const { Title, Text } = Typography;
const { TabPane } = Tabs;

export const ProfilePage = () => {
  const { user, logout, updateProfile, changePassword } = useAuth();
  const [profileForm] = Form.useForm();
  const [passwordForm] = Form.useForm();
  const [updating, setUpdating] = useState(false);
  const [changing, setChanging] = useState(false);

  const handleUpdateProfile = async (values) => {
    setUpdating(true);
    const result = await updateProfile(values);
    setUpdating(false);
    if (result.success) {
      message.success('Профиль обновлён');
    } else {
      message.error(result.error);
    }
  };

  const handleChangePassword = async (values) => {
    setChanging(true);
    const result = await changePassword(values.oldPassword, values.newPassword);
    setChanging(false);
    if (result.success) {
      message.success('Пароль изменён');
      passwordForm.resetFields();
    } else {
      message.error(result.error);
    }
  };

  return (
    <Card style={{ maxWidth: 600, margin: '0 auto' }}>
      <Title level={2}>Профиль</Title>
      <Tabs defaultActiveKey="1">
        <TabPane tab="Основное" key="1">
          <div style={{ marginBottom: 20 }}>
            <Text strong>Email: </Text> <Text>{user?.email}</Text><br />
            <Text strong>Имя: </Text> <Text>{user?.credentials}</Text>
          </div>
          <Form
            form={profileForm}
            layout="vertical"
            onFinish={handleUpdateProfile}
            initialValues={{ email: user?.email, credentials: user?.credentials }}
          >
            <Form.Item
              name="email"
              label="Email"
              rules={[{ required: true, type: 'email', message: 'Введите корректный email' }]}
            >
              <Input />
            </Form.Item>
            <Form.Item
              name="credentials"
              label="Имя"
              rules={[{ required: true, message: 'Введите имя' }]}
            >
              <Input />
            </Form.Item>
            <Form.Item>
              <Button type="primary" htmlType="submit" loading={updating}>
                Обновить профиль
              </Button>
            </Form.Item>
          </Form>
        </TabPane>
        <TabPane tab="Смена пароля" key="2">
          <Form
            form={passwordForm}
            layout="vertical"
            onFinish={handleChangePassword}
          >
            <Form.Item
              name="oldPassword"
              label="Старый пароль"
              rules={[{ required: true, message: 'Введите старый пароль' }]}
            >
              <Input.Password />
            </Form.Item>
            <Form.Item
              name="newPassword"
              label="Новый пароль"
              rules={[{ required: true, message: 'Введите новый пароль' }]}
            >
              <Input.Password />
            </Form.Item>
            <Form.Item>
              <Button type="primary" htmlType="submit" loading={changing}>
                Сменить пароль
              </Button>
            </Form.Item>
          </Form>
        </TabPane>
      </Tabs>
      <div style={{ marginTop: 20 }}>
        <Button type="primary" danger onClick={logout}>
          Выйти
        </Button>
      </div>
    </Card>
  );
};
</file>

<file path="pages/tariffs/TariffsPage.jsx">
// pages/tariffs/TariffsPage.jsx
import React, { useEffect, useState } from 'react';
import {
  Table,
  Button,
  Space,
  Popconfirm,
  message,
  Modal,
  Form,
  Input,
  InputNumber,
  Typography,
  Spin,
} from 'antd';
import { PlusOutlined, EditOutlined, DeleteOutlined } from '@ant-design/icons';
import { getTariffs, createTariff, updateTariff, deleteTariff } from '../../services/credit';

const { Title } = Typography;

export const TariffsPage = () => {
  const [tariffs, setTariffs] = useState([]);
  const [loading, setLoading] = useState(false);
  const [modalVisible, setModalVisible] = useState(false);
  const [editingTariff, setEditingTariff] = useState(null); // null – создание, объект – редактирование
  const [form] = Form.useForm();
  const [submitting, setSubmitting] = useState(false);

  // Загрузка списка тарифов
  const fetchTariffs = async () => {
    setLoading(true);
    try {
      const data = await getTariffs();
      setTariffs(data);
    } catch (error) {
      message.error(error.message);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchTariffs();
  }, []);

  // Открыть модалку для создания
  const handleCreate = () => {
    setEditingTariff(null);
    form.resetFields();
    setModalVisible(true);
  };

  // Открыть модалку для редактирования
  const handleEdit = (record) => {
    setEditingTariff(record);
    form.setFieldsValue({
      name: record.name,
      interestRate: record.interestRate,
      maxAmount: record.maxAmount,
      maxTermDays: record.maxTermDays,
    });
    setModalVisible(true);
  };

  // Удаление тарифа
  const handleDelete = async (id) => {
    try {
      await deleteTariff(id);
      message.success('Тариф удалён');
      fetchTariffs(); // обновляем список
    } catch (error) {
      message.error(error.message);
    }
  };

  // Сохранение (создание или обновление)
  const handleSave = async (values) => {
    setSubmitting(true);
    try {
      if (editingTariff) {
        await updateTariff(editingTariff.id, values);
        message.success('Тариф обновлён');
      } else {
        await createTariff(values);
        message.success('Тариф создан');
      }
      setModalVisible(false);
      fetchTariffs();
    } catch (error) {
      message.error(error.message);
    } finally {
      setSubmitting(false);
    }
  };

  // Колонки таблицы
  const columns = [
    {
      title: 'Название',
      dataIndex: 'name',
      key: 'name',
    },
    {
      title: 'Ставка %',
      dataIndex: 'interestRate',
      key: 'interestRate',
      render: (value) => `${value} %`,
    },
    {
      title: 'Макс. сумма',
      dataIndex: 'maxAmount',
      key: 'maxAmount',
      render: (value) => `${value.toLocaleString()} ₽`,
    },
    {
      title: 'Срок (дней)',
      dataIndex: 'maxTermDays',
      key: 'maxTermDays',
      render: (value) => `${value} дн.`,
    },
    {
      title: 'Действия',
      key: 'actions',
      render: (_, record) => (
        <Space>
          <Button
            icon={<EditOutlined />}
            size="small"
            onClick={() => handleEdit(record)}
          >
            Редактировать
          </Button>
          <Popconfirm
            title="Удалить тариф?"
            description="Вы уверены, что хотите удалить этот тариф?"
            okText="Да"
            cancelText="Нет"
            onConfirm={() => handleDelete(record.id)}
          >
            <Button icon={<DeleteOutlined />} size="small" danger>
              Удалить
            </Button>
          </Popconfirm>
        </Space>
      ),
    },
  ];

  return (
    <div>
      <Title level={2}>Управление тарифами</Title>
      <Button
        type="primary"
        icon={<PlusOutlined />}
        onClick={handleCreate}
        style={{ marginBottom: 16 }}
      >
        Создать тариф
      </Button>

      {loading ? (
        <Spin size="large" style={{ display: 'block', margin: '50px auto' }} />
      ) : (
        <Table
          dataSource={tariffs}
          columns={columns}
          rowKey="id"
          pagination={{ pageSize: 10 }}
        />
      )}

      {/* Модальное окно создания/редактирования */}
      <Modal
        open={modalVisible}
        title={editingTariff ? 'Редактировать тариф' : 'Создать тариф'}
        onCancel={() => setModalVisible(false)}
        footer={null}
        destroyOnClose
      >
        <Form
          form={form}
          layout="vertical"
          onFinish={handleSave}
          initialValues={{
            interestRate: undefined,
            maxAmount: undefined,
            maxTermDays: undefined,
          }}
        >
          <Form.Item
            name="name"
            label="Название"
            rules={[{ required: true, message: 'Введите название тарифа' }]}
          >
            <Input />
          </Form.Item>

          <Form.Item
            name="interestRate"
            label="Процентная ставка (%)"
            rules={[
              { required: true, message: 'Введите ставку' },
              { type: 'number', min: 0.01, max: 100, message: 'Ставка от 0.01 до 100' },
            ]}
          >
            <InputNumber style={{ width: '100%' }} step={0.1} precision={2} />
          </Form.Item>

          <Form.Item
            name="maxAmount"
            label="Максимальная сумма"
            rules={[
              { required: true, message: 'Введите максимальную сумму' },
              { type: 'number', min: 0.01, message: 'Сумма должна быть больше 0' },
            ]}
          >
            <InputNumber style={{ width: '100%' }} step={1000} precision={2} />
          </Form.Item>

          <Form.Item
            name="maxTermDays"
            label="Максимальный срок (дней)"
            rules={[
              { required: true, message: 'Введите срок в днях' },
              { type: 'number', min: 1, message: 'Срок должен быть не менее 1 дня' },
            ]}
          >
            <InputNumber style={{ width: '100%' }} step={1} precision={0} />
          </Form.Item>

          <Form.Item style={{ marginBottom: 0, textAlign: 'right' }}>
            <Space>
              <Button onClick={() => setModalVisible(false)}>Отмена</Button>
              <Button type="primary" htmlType="submit" loading={submitting}>
                {editingTariff ? 'Сохранить' : 'Создать'}
              </Button>
            </Space>
          </Form.Item>
        </Form>
      </Modal>
    </div>
  );
};
</file>

<file path="pages/users/UsersPage.jsx">
// pages/users/UsersPage.jsx
import React, { useEffect, useState, useCallback } from 'react';
import { Table, Input, Button, Drawer, Spin, message, Typography, Space, Divider, Tag } from 'antd';
import { SearchOutlined, EyeOutlined, UnlockOutlined, LockOutlined } from '@ant-design/icons';
import { useAuth } from '../../context/authContext';
import { searchUsers, getUserById } from '../../services/users';
import debounce from 'lodash/debounce';
import { addUserRole, removeUserRole, blockUser, unblockUser } from '../../services/users';

const { Title, Text } = Typography;

export const UsersPage = () => {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedUser, setSelectedUser] = useState(null);
  const [drawerVisible, setDrawerVisible] = useState(false);
  const [userDetailsLoading, setUserDetailsLoading] = useState(false);
  const [roleActionLoading, setRoleActionLoading] = useState(false);
const [blockActionLoading, setBlockActionLoading] = useState(false);

    const { user } = useAuth();

  // Загрузка пользователей с учётом поискового запроса
  const fetchUsers = async (query) => {
    setLoading(true);
    try {
      const data = await searchUsers(query);
      setUsers(data);
    } catch (error) {
      message.error(error.message || 'Ошибка загрузки пользователей');
    } finally {
      setLoading(false);
    }
  };

  // Первоначальная загрузка (пустой запрос — все пользователи)
  useEffect(() => {
    fetchUsers('');
  }, []);

  // Debounced поиск (ждём 500 мс после остановки ввода)
  const debouncedSearch = useCallback(
    debounce((query) => {
      fetchUsers(query);
    }, 500),
    []
  );

  const handleSearchChange = (e) => {
    const value = e.target.value;
    setSearchQuery(value);
    debouncedSearch(value);
  };

  // Открытие Drawer с загрузкой деталей пользователя
  const showUserDetails = async (user) => {
    setSelectedUser(user);
    setDrawerVisible(true);
    setUserDetailsLoading(true);
    try {
      // Можно повторно запросить свежие данные, но можно использовать уже имеющиеся
      // Для простоты используем то, что есть в таблице
      // Если нужно точнее — раскомментируйте:
      // const detailed = await getUserById(user.id);
      // setSelectedUser(detailed);
    } catch (error) {
      message.error('Не удалось загрузить детали пользователя');
    } finally {
      setUserDetailsLoading(false);
    }
  };

  const closeDrawer = () => {
    setDrawerVisible(false);
    setSelectedUser(null);
  };

  const handleBlockUser = async (userId) => {
  setBlockActionLoading(true);
  try {
    await blockUser(userId);
    message.success('Пользователь заблокирован');
    const updated = await getUserById(userId);
    setSelectedUser(updated);
  } catch (error) {
    message.error(error.message || 'Ошибка блокировки');
  } finally {
    setBlockActionLoading(false);
  }
};

const handleUnblockUser = async (userId) => {
  setBlockActionLoading(true);
  try {
    await unblockUser(userId);
    message.success('Пользователь разблокирован');
    const updated = await getUserById(userId);
    setSelectedUser(updated);
  } catch (error) {
    message.error(error.message || 'Ошибка разблокировки');
  } finally {
    setBlockActionLoading(false);
  }
};

  const columns = [
    {
      title: 'ID',
      dataIndex: 'id',
      key: 'id',
      render: (id) => <code>{id.substring(0, 8)}...</code>,
    },
    {
      title: 'Email',
      dataIndex: 'email',
      key: 'email',
    },
    {
      title: 'Имя',
      dataIndex: 'credentials',
      key: 'credentials',
      render: (text) => text || '—',
    },
    {
      title: 'Действия',
      key: 'actions',
      render: (_, record) => (
        <Button
          icon={<EyeOutlined />}
          size="small"
          onClick={(e) => {
            e.stopPropagation(); // предотвращаем срабатывание клика по строке
            showUserDetails(record);
          }}
        >
          Просмотр
        </Button>
      ),
    },
  ];

    const handleAssignEmployee = async (userId) => {
    setRoleActionLoading(true);
    try {
        await addUserRole(userId, 'Employee');
        message.success('Роль Employee назначена');
    } catch (error) {
        message.error(error.message || 'Ошибка назначения роли');
    } finally {
        setRoleActionLoading(false);
        fetchUsers(searchQuery);
    }
    };

    const handleRemoveEmployee = async (userId) => {
    setRoleActionLoading(true);
    try {
        await removeUserRole(userId, 'Employee');
        message.success('Роль Employee снята');
    } catch (error) {
        message.error(error.message || 'Ошибка снятия роли');
    } finally {
        setRoleActionLoading(false);
        fetchUsers(searchQuery);
    }
    };

  return (
    <div>
      <Title level={2}>Пользователи</Title>

      {/* Поле поиска */}
      <Input
        placeholder="Поиск по имени"
        prefix={<SearchOutlined />}
        value={searchQuery}
        onChange={handleSearchChange}
        style={{ width: 300, marginBottom: 20 }}
        allowClear
      />

      {loading ? (
        <Spin size="large" style={{ display: 'block', margin: '50px auto' }} />
      ) : (
        <Table
          dataSource={users}
          columns={columns}
          rowKey="id"
          pagination={{ pageSize: 10 }}
          onRow={(record) => ({
            onClick: () => showUserDetails(record),
            style: { cursor: 'pointer' },
          })}
        />
      )}

      {/* Боковая панель с деталями пользователя */}
      <Drawer
        title="Информация о пользователе"
        placement="right"
        width={500}
        onClose={closeDrawer}
        open={drawerVisible}
      >
        {userDetailsLoading ? (
          <Spin />
        ) : selectedUser ? (
          <Space direction="vertical" size="middle" style={{ width: '100%' }}>
            <div>
              <Text strong>ID:</Text> <Text>{selectedUser.id}</Text>
            </div>
            <div>
              <Text strong>Email:</Text> <Text>{selectedUser.email}</Text>
            </div>
            <div>
              <Text strong>Имя:</Text> <Text>{selectedUser.credentials || '—'}</Text>
            </div>
            
                  {/* Статус блокировки */}
      <div>
        <Text strong>Статус:</Text>{' '}
        {selectedUser.isBlocked ? (
          <Tag color="red">Заблокирован</Tag>
        ) : (
          <Tag color="green">Активен</Tag>
        )}
      </div>

      {/* Роли */}
      <div>
        <Text strong>Роли:</Text>{' '}
        {selectedUser.roles && selectedUser.roles.length > 0 ? (
          selectedUser.roles.map(role => (
            <Tag key={role} color="blue">{role}</Tag>
          ))
        ) : (
          <Text type="secondary">Нет ролей</Text>
        )}
      </div>

      <Divider />

      {/* Управление ролью Employee */}
      {user.id != selectedUser.id && <Space>
        {selectedUser.roles?.includes('Employee') ? (
          <Button
            danger
            onClick={() => handleRemoveEmployee(selectedUser.id)}
            loading={roleActionLoading}
          >
            Снять роль Employee
          </Button>
        ) : (
          <Button
            type="primary"
            onClick={() => handleAssignEmployee(selectedUser.id)}
            loading={roleActionLoading}
          >
            Назначить Employee
          </Button>
        )}
      </Space>}

      {/* Управление блокировкой (если доступно) */}
      {user.id != selectedUser.id &&<Space style={{ marginTop: 16 }}>
        {selectedUser.isBlocked ? (
          <Button
            icon={<UnlockOutlined />}
            onClick={() => handleUnblockUser(selectedUser.id)}
            loading={blockActionLoading}
          >
            Разблокировать
          </Button>
        ) : (
          <Button
            icon={<LockOutlined />}
            danger
            onClick={() => handleBlockUser(selectedUser.id)}
            loading={blockActionLoading}
          >
            Заблокировать
          </Button>
        )}
      </Space> }
          </Space>
        ) : (
          <Text>Пользователь не выбран</Text>
        )}
      </Drawer>
    </div>
  );
};
</file>

<file path="services/api.js">
// services/api.js
import { jwtDecode } from 'jwt-decode';

// Функции для работы с токенами (общие)
const getAccessToken = () => localStorage.getItem('accessToken');
const getRefreshToken = () => localStorage.getItem('refreshToken');

const setTokens = (accessToken, refreshToken) => {
  localStorage.setItem('accessToken', accessToken);
  if (refreshToken) localStorage.setItem('refreshToken', refreshToken);
};

const removeTokens = () => {
  localStorage.removeItem('accessToken');
  localStorage.removeItem('refreshToken');
};

const getRoleFromToken = (token) => {
  try {
    const decoded = jwtDecode(token);
    return decoded.role; // предполагается поле "role"
  } catch {
    return null;
  }
};

const isRoleAllowed = (role) => role !== 'Customer';

// Фабрика для создания API-клиента с заданным baseURL
const createApiRequest = (baseURL) => {
  return async function apiRequest(endpoint, options = {}) {
    const url = `${baseURL}${endpoint}`;
    const accessToken = getAccessToken();

    const headers = {
      'Content-Type': 'application/json',
      ...options.headers,
    };

    if (accessToken) {
      headers.Authorization = `Bearer ${accessToken}`;
    }

    let response = await fetch(url, { ...options, headers });

    // Попытка обновить токен при 401
    if (response.status === 401 && getRefreshToken()) {
      const newTokens = await refreshAccessToken();
      if (newTokens) {
        headers.Authorization = `Bearer ${newTokens.accessToken}`;
        response = await fetch(url, { ...options, headers });
      } else {
        removeTokens();
        window.location.href = '/login';
        throw new Error('Session expired');
      }
    }

    return response;
  };
};

// Функция обновления токена (использует baseURL Auth, так как endpoint принадлежит Auth)
async function refreshAccessToken() {
  const refreshToken = getRefreshToken();
  if (!refreshToken) return null;

  const authBaseURL = process.env.REACT_APP_AUTH_API_URL || 'http://localhost:5000';
  try {
    const response = await fetch(`${authBaseURL}/api/auth/refresh?token=${refreshToken}`, {
      method: 'POST',
    });
    if (response.ok) {
      const data = await response.json();
      setTokens(data.accessToken, data.refreshToken || refreshToken);
      return { accessToken: data.accessToken };
    } else {
      removeTokens();
      return null;
    }
  } catch {
    removeTokens();
    return null;
  }
}

// Создаём два экземпляра: для Auth и для Core
const authApiRequest = createApiRequest(process.env.REACT_APP_AUTH_API_URL || 'http://localhost:5000');
const coreApiRequest = createApiRequest(process.env.REACT_APP_CORE_API_URL || 'http://localhost:5001');
const creditApiRequest = createApiRequest(process.env.REACT_APP_CREDIT_API_URL || 'http://localhost:5002');

export {
  authApiRequest,
  coreApiRequest,
  creditApiRequest,
  setTokens,
  removeTokens,
  getAccessToken,
  getRefreshToken,
  getRoleFromToken,
  isRoleAllowed,
};
</file>

<file path="services/core.js">
// services/core.js
import { coreApiRequest } from './api';

export const getAccounts = async () => {
  const response = await coreApiRequest('/api/accounts/employee', { method: 'GET' });
  if (!response.ok) {
    throw new Error('Failed to fetch accounts');
  }
  return response.json(); // предполагаем, что возвращается массив объектов AccountDto
};

export const getAccountById = async (id) => {
  const response = await coreApiRequest(`/api/accounts/employee/${id}`, { method: 'GET' });
  if (!response.ok) {
    throw new Error('Failed to fetch account');
  }
  return response.json();
};

export const deleteAccount = async (id) => {
  const response = await coreApiRequest(`/api/accounts/employee/${id}`, { method: 'DELETE' });
  if (!response.ok) {
    throw new Error('Failed to delete account');
  }
  return response.json();
};

export const deposit = async (id, { amount, description }) => {
    const body = {
        sourceId: null,
        sourceType: "RealWorld",
        targetId: id,
        targetType: "Account",
        amount,
        description
    }

  const response = await coreApiRequest(`/api/transactions`, { method: 'POST', body: JSON.stringify(body)  });
  if (!response.ok) {
    throw new Error('Failed to deposit');
  }
  return response.json();
};

export const withdraw = async (id, { amount, description }) => {
    const body = {
        sourceId: id,
        sourceType: "Account",
        targetId: null,
        targetType: "RealWorld",
        amount,
        description
    }

  const response = await coreApiRequest(`/api/transactions`, { method: 'POST', body: JSON.stringify(body)  });
  if (!response.ok) {
    throw new Error('Failed to deposit');
  }
  return response.json();
};

export const getAccountTransactions = async (accountId, from, to) => {
  let url = `/api/accounts/employee/${accountId}/transactions`;
  const params = new URLSearchParams();
  if (from) params.append('from', from.toISOString());
  if (to) params.append('to', to.toISOString());
  if (params.toString()) url += `?${params.toString()}`;
  
  const response = await coreApiRequest(url, { method: 'GET' });
  if (!response.ok) {
    throw new Error('Failed to fetch transactions');
  }
  return response.json();
};
</file>

<file path="services/credit.js">
// services/credit.js
import { creditApiRequest } from './api';

/**
 * Получить список всех тарифов
 * @returns {Promise<Array>} массив TariffDto
 */
export const getTariffs = async () => {
  const response = await creditApiRequest('/api/tariffs', { method: 'GET' });
  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(error.message || 'Не удалось загрузить тарифы');
  }
  return response.json();
};

/**
 * Создать новый тариф
 * @param {Object} data - поля: name, interestRate, maxAmount, maxTermDays
 * @returns {Promise<Object>} созданный TariffDto
 */
export const createTariff = async (data) => {
  const response = await creditApiRequest('/api/tariffs', {
    method: 'POST',
    body: JSON.stringify(data),
  });
  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(error.message || 'Не удалось создать тариф');
  }
  return response.json();
};

/**
 * Получить тариф по ID
 * @param {string} id
 * @returns {Promise<Object>} TariffDto
 */
export const getTariffById = async (id) => {
  const response = await creditApiRequest(`/api/tariffs/${id}`, { method: 'GET' });
  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(error.message || 'Не удалось загрузить тариф');
  }
  return response.json();
};

/**
 * Обновить существующий тариф
 * @param {string} id
 * @param {Object} data - поля: name, interestRate, maxAmount, maxTermDays
 * @returns {Promise<Object>} обновлённый TariffDto
 */
export const updateTariff = async (id, data) => {
  const response = await creditApiRequest(`/api/tariffs/${id}`, {
    method: 'PUT',
    body: JSON.stringify(data),
  });
  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(error.message || 'Не удалось обновить тариф');
  }
  return response.json();
};

/**
 * Удалить тариф по ID
 * @param {string} id
 * @returns {Promise<void>}
 */
export const deleteTariff = async (id) => {
  const response = await creditApiRequest(`/api/tariffs/${id}`, { method: 'DELETE' });
  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(error.message || 'Не удалось удалить тариф');
  }
  // при успехе возвращается пустой ответ с кодом 200
};
</file>

<file path="services/users.js">
// services/users.js
import { authApiRequest } from './api';

/**
 * Поиск пользователей по запросу
 * @param {string} query - строка поиска (email или имя)
 * @returns {Promise<Array>} массив пользователей
 */
export const searchUsers = async (query = '') => {
  const response = await authApiRequest(`/api/users/search?query=${encodeURIComponent(query)}`, {
    method: 'GET',
  });
  if (!response.ok) {
    throw new Error('Не удалось загрузить пользователей');
  }
  return response.json();
};

/**
 * Получение пользователя по ID
 * @param {string} id - UUID пользователя
 * @returns {Promise<Object>} объект пользователя
 */
export const getUserById = async (id) => {
  const response = await authApiRequest(`/api/users/${id}`, { method: 'GET' });
  if (!response.ok) {
    throw new Error('Не удалось загрузить данные пользователя');
  }
  return response.json();
};

export const addUserRole = async (userId, role) => {
  const response = await authApiRequest(`/api/users/${userId}/role?role=${encodeURIComponent(role)}`, {
    method: 'POST',
  });
  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(error.message || 'Не удалось добавить роль');
  }
  return response.json(); // предположительно возвращает что-то или просто ok
};

export const removeUserRole = async (userId, role) => {
  const response = await authApiRequest(`/api/users/${userId}/role?role=${encodeURIComponent(role)}`, {
    method: 'DELETE',
  });
  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(error.message || 'Не удалось удалить роль');
  }
  return response.json();
};

/**
 * Заблокировать пользователя
 * @param {string} userId
 * @returns {Promise<Object>}
 */
export const blockUser = async (userId) => {
  const response = await authApiRequest(`/api/auth/block/${userId}`, {
    method: 'POST',
  });
  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(error.message || 'Не удалось заблокировать пользователя');
  }
  return response.json();
};

/**
 * Разблокировать пользователя
 * @param {string} userId
 * @returns {Promise<Object>}
 */
export const unblockUser = async (userId) => {
  const response = await authApiRequest(`/api/auth/unblock/${userId}`, {
    method: 'POST',
  });
  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(error.message || 'Не удалось разблокировать пользователя');
  }
  return response.json();
};

// (Опционально) функции для управления ролями можно добавить позже
// export const addUserRole = async (userId, role) => { ... }
// export const removeUserRole = async (userId, role) => { ... }
</file>

</files>
